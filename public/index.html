<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Null's Brawl Esport ¬∑ Top 50</title>
    <meta
      name="description"
      content="Classement officiel Null's Brawl Esport. Consultez le Top 50 avec score pond√©r√© (30% Elo, 70% MMR) et tiers."
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #05060a;
        --bg-alt: rgba(255, 255, 255, 0.04);
        --card: rgba(255, 255, 255, 0.08);
        --text: #f7f8fa;
        --muted: rgba(247, 248, 250, 0.7);
        --accent: #facc15;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(250, 204, 21, 0.2), transparent 60%), var(--bg);
        color: var(--text);
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 3rem 1.5rem 2rem;
        text-align: center;
      }

      header h1 {
        margin: 0;
        font-size: clamp(2.5rem, 4vw, 3.5rem);
        letter-spacing: 0.04em;
      }

      header p {
        margin: 0.75rem auto 0;
        max-width: 52ch;
        color: var(--muted);
        line-height: 1.6;
      }

      main {
        flex: 1;
        width: min(960px, 100%);
        margin: 0 auto 4rem;
        padding: 0 1.5rem 4rem;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }

      .card {
        background: var(--card);
        border-radius: 20px;
        padding: clamp(1rem, 2vw, 1.5rem);
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 20px 60px rgba(5, 6, 10, 0.45);
      }

      .status {
        font-size: 1rem;
        color: var(--muted);
        text-align: center;
        padding: 2rem 1rem;
      }

      .card h2 {
        margin-top: 0;
        font-size: 1.4rem;
      }

      .card p {
        color: var(--muted);
        line-height: 1.5;
      }

      ol.ranking {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .player {
        display: grid;
        grid-template-columns: 56px 1fr auto;
        align-items: center;
        gap: 1.25rem;
        padding: 1rem 1.25rem;
        border-radius: 16px;
        background: var(--bg-alt);
        transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
        border: 1px solid transparent;
      }

      .player-top {
        background: linear-gradient(120deg, rgba(250, 204, 21, 0.14), rgba(255, 255, 255, 0.04)) var(--bg-alt);
        padding: 1.4rem 1.5rem;
        border: 1px solid rgba(250, 204, 21, 0.35);
        box-shadow: 0 25px 50px rgba(5, 6, 10, 0.5);
      }

      .player-top .rank {
        font-size: 2.15rem;
      }

      .player-top h2 {
        font-size: 1.3rem;
      }

      .player-top .stats {
        font-size: 1.05rem;
      }

      .player-top-1 {
        background: linear-gradient(145deg, rgba(250, 204, 21, 0.35), rgba(250, 204, 21, 0.1));
      }

      .player-top-2 {
        background: linear-gradient(145deg, rgba(226, 232, 240, 0.35), rgba(250, 204, 21, 0.1));
      }

      .player-top-3 {
        background: linear-gradient(145deg, rgba(234, 179, 8, 0.25), rgba(250, 204, 21, 0.08));
      }

      .player:hover {
        transform: translateY(-2px);
        border-color: rgba(250, 204, 21, 0.25);
      }

      .rank {
        font-size: 1.5rem;
        font-weight: 700;
        text-align: center;
      }

      .player h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .player small {
        display: block;
        margin-top: 0.25rem;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .stats {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.35rem;
        font-size: 0.95rem;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        background: rgba(250, 204, 21, 0.14);
        color: var(--accent);
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.04em;
      }

      .badge-tier-s {
        background: linear-gradient(90deg, #fcd34d, #fbbf24, #f59e0b);
        color: #1f1b0d;
        box-shadow: 0 0 12px rgba(252, 211, 77, 0.45);
      }

      .auth-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
        margin-top: 1rem;
      }

      button.cta {
        background: var(--accent);
        color: #0a0b10;
        border: none;
        border-radius: 999px;
        padding: 0.6rem 1.4rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button.cta:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 30px rgba(250, 204, 21, 0.25);
      }

      button.cta[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .auth-status {
        text-align: center;
        font-size: 0.95rem;
        color: var(--muted);
      }

      .admin-grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        margin-bottom: 1.5rem;
      }

      .admin-grid h3 {
        margin: 0 0 0.75rem;
        font-size: 1.1rem;
      }

      .admin-tools {
        display: flex;
        flex-wrap: wrap;
        align-items: flex-end;
        gap: 1rem;
        margin-bottom: 1.5rem;
      }

      .search-group {
        flex: 1;
        min-width: 220px;
      }

      .search-group label {
        display: block;
        margin-bottom: 0.55rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .search-group input[type='search'] {
        width: 100%;
        padding: 0.55rem 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: var(--bg-alt);
        color: var(--text);
        font-size: 0.95rem;
      }

      .search-group input[type='search']::placeholder {
        color: var(--muted);
      }

      .admin-grid select {
        width: 100%;
        padding: 0.55rem 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: var(--bg-alt);
        color: var(--text);
        font-size: 0.95rem;
      }

      .admin-grid select option {
        color: #0a0b10;
        background: #f7f8fa;
      }

      .admin-grid label {
        display: block;
        margin-bottom: 0.55rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .queue-builder {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .queue-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: flex-end;
      }

      .queue-tier-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .queue-tier-filters label {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        background: var(--bg-alt);
        border-radius: 999px;
        padding: 0.35rem 0.85rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        font-size: 0.9rem;
      }

      .queue-tier-filters input[type='checkbox'] {
        accent-color: var(--accent);
      }

      .queue-search {
        flex: 1;
        min-width: 220px;
      }

      .queue-search label {
        display: block;
        margin-bottom: 0.55rem;
        font-size: 0.9rem;
        color: var(--muted);
      }

      .queue-search input[type='search'] {
        width: 100%;
        padding: 0.55rem 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: var(--bg-alt);
        color: var(--text);
        font-size: 0.95rem;
      }

      .queue-columns {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .queue-list h3 {
        margin: 0 0 0.75rem;
        font-size: 1.1rem;
      }

      .queue-items {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }

      .queue-item {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        align-items: center;
        padding: 0.75rem 1rem;
        border-radius: 14px;
        background: var(--bg-alt);
        border: 1px solid transparent;
      }

      .queue-item strong {
        display: block;
        font-size: 1rem;
      }

      .queue-item small {
        display: block;
        color: var(--muted);
        font-size: 0.85rem;
        margin-top: 0.2rem;
      }

      .queue-info {
        flex: 1;
        min-width: 0;
      }

      .queue-actions {
        display: inline-flex;
        gap: 0.35rem;
      }

      .queue-button {
        background: rgba(250, 204, 21, 0.18);
        color: var(--accent);
        border: none;
        border-radius: 10px;
        padding: 0.35rem 0.75rem;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      .queue-button:hover {
        background: rgba(250, 204, 21, 0.28);
        transform: translateY(-1px);
      }

      .queue-button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        transform: none;
        background: rgba(255, 255, 255, 0.1);
      }

      .queue-button.danger {
        background: rgba(248, 113, 113, 0.2);
        color: #f87171;
      }

      .queue-button.danger:hover {
        background: rgba(248, 113, 113, 0.28);
      }

      .queue-empty {
        margin: 0;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .queue-available-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
        padding: 0.65rem 0.85rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.04);
      }

      .queue-available-item strong {
        display: block;
        font-size: 0.95rem;
      }

      .queue-available-item small {
        display: block;
        font-size: 0.8rem;
        color: var(--muted);
        margin-top: 0.2rem;
      }

      .queue-available-info {
        flex: 1;
        min-width: 0;
      }

      .queue-empty-state {
        padding: 0.85rem 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.04);
        color: var(--muted);
        font-size: 0.9rem;
      }

      .admin-message {
        text-align: center;
        min-height: 1.5rem;
        font-size: 0.9rem;
      }

      .admin-message.success {
        color: #34d399;
      }

      .admin-message.error {
        color: #f87171;
      }

      footer {
        padding: 2rem 1.5rem 3rem;
        text-align: center;
        color: var(--muted);
        font-size: 0.85rem;
      }

      @media (max-width: 640px) {
        .player {
          grid-template-columns: 44px 1fr;
          grid-template-areas:
            'rank name'
            'rank stats';
          gap: 0.75rem;
        }

        .rank {
          grid-area: rank;
          font-size: 1.25rem;
        }

        .player h2,
        .player small {
          grid-area: name;
        }

        .stats {
          grid-area: stats;
          align-items: flex-start;
          flex-direction: row;
          flex-wrap: wrap;
          font-size: 0.85rem;
          gap: 0.5rem 1rem;
        }

        .queue-controls {
          flex-direction: column;
          align-items: stretch;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Classement Officiel ¬∑ Top 50</h1>
      <p>
        Retrouve les 50 meilleurs joueurs Null's Brawl Esport class√©s par score pond√©r√© (30% Elo matchmaking, 70% MMR panel
        admin). Le classement est mis √† jour automatiquement √† partir de la base de donn√©es officielle.
      </p>
    </header>
    <main>
      <section class="card">
        <h2>Connexion</h2>
        <p>
          Connecte-toi avec ton compte Discord pour acc√©der aux outils r√©serv√©s aux administrateurs. Les membres non
          autoris√©s peuvent toujours consulter le classement mais ne pourront pas modifier les donn√©es.
        </p>
        <div id="auth-status" class="auth-status">V√©rification de la session en cours‚Ä¶</div>
        <div class="auth-controls">
          <button id="login-discord" class="cta">Connexion Discord</button>
          <button id="logout" class="cta" hidden>Se d√©connecter</button>
        </div>
      </section>

      <section id="admin-panel" class="card" hidden>
        <h2>Panel administrateur</h2>
        <p>
          S√©lectionne trois vainqueurs et trois perdants pour enregistrer un nouveau r√©sultat. Le MMR sera ajust√© selon
          un mod√®le Elo pond√©r√© (facteur K = 100) en tenant compte du poids individuel de chaque joueur et des
          probabilit√©s de victoire attendues.
        </p>
        <form id="match-form">
          <div class="admin-tools">
            <div class="search-group">
              <label for="player-search">Rechercher un joueur</label>
              <input
                type="search"
                id="player-search"
                placeholder="Tape un pseudo pour filtrer la liste"
                autocomplete="off"
              />
            </div>
            <button type="button" id="add-player" class="cta">Ajouter un joueur (1000 MMR)</button>
            <button type="button" id="reset-mmr" class="cta">R√©initialiser tous les MMR</button>
          </div>
          <div class="admin-grid">
            <div>
              <h3>Vainqueurs</h3>
              <label for="winner-1">Vainqueur #1</label>
              <select id="winner-1" data-role="winner"></select>
              <label for="winner-2">Vainqueur #2</label>
              <select id="winner-2" data-role="winner"></select>
              <label for="winner-3">Vainqueur #3</label>
              <select id="winner-3" data-role="winner"></select>
            </div>
            <div>
              <h3>Perdants</h3>
              <label for="loser-1">Perdant #1</label>
              <select id="loser-1" data-role="loser"></select>
              <label for="loser-2">Perdant #2</label>
              <select id="loser-2" data-role="loser"></select>
              <label for="loser-3">Perdant #3</label>
              <select id="loser-3" data-role="loser"></select>
            </div>
          </div>
          <div class="auth-controls">
            <button type="submit" class="cta">Enregistrer le match</button>
          </div>
          <div id="match-status" class="admin-message" aria-live="polite"></div>
        </form>
      </section>

      <section id="queue-builder" class="card" hidden>
        <h2>Cr√©er une file personnalis√©e</h2>
        <p>
          Filtre les meilleurs joueurs par tier et compose une file temporaire pour organiser rapidement des parties
          √©quilibr√©es entre membres de niveau similaire.
        </p>
        <div class="queue-builder">
          <div class="queue-controls">
            <div id="queue-tier-filters" class="queue-tier-filters" aria-label="Filtrer par tier"></div>
            <div class="queue-search">
              <label for="queue-player-search">Rechercher un joueur</label>
              <input
                type="search"
                id="queue-player-search"
                placeholder="Pseudo, tier ou √©quipe"
                autocomplete="off"
              />
            </div>
            <button type="button" id="queue-reset" class="cta">R√©initialiser la file</button>
          </div>
          <div class="queue-columns">
            <div class="queue-list" aria-live="polite">
              <h3>Joueurs disponibles</h3>
              <ul id="queue-available" class="queue-items"></ul>
            </div>
            <div class="queue-list" aria-live="polite">
              <h3>File actuelle</h3>
              <ul id="queue-selected" class="queue-items"></ul>
              <p id="queue-empty" class="queue-empty">Aucun joueur s√©lectionn√© pour le moment.</p>
            </div>
          </div>
        </div>
      </section>

      <section class="card">
        <div id="status" class="status">Chargement du classement‚Ä¶</div>
        <ol id="ranking" class="ranking" hidden></ol>
      </section>
    </main>
    <footer>
      Null's Brawl Esport ¬∑ Top 50 communautaire ‚Äî Donn√©es fournies par Supabase
    </footer>

    <script type="module">
      import { createClient } from 'https://esm.sh/@supabase/supabase-js@2?bundle';

      const API_BASE = (window.APP_CONFIG?.apiBase || `${window.location.origin.replace(/\/$/, '')}/api`).replace(
        /\/$/,
        ''
      );

      const statusElement = document.getElementById('status');
      const rankingElement = document.getElementById('ranking');
      const loginButton = document.getElementById('login-discord');
      const logoutButton = document.getElementById('logout');
      const authStatus = document.getElementById('auth-status');
      const adminPanel = document.getElementById('admin-panel');
      const matchForm = document.getElementById('match-form');
      const matchStatus = document.getElementById('match-status');
      const winnerSelects = Array.from(document.querySelectorAll('select[data-role="winner"]'));
      const loserSelects = Array.from(document.querySelectorAll('select[data-role="loser"]'));
      const addPlayerButton = document.getElementById('add-player');
      const resetMMRButton = document.getElementById('reset-mmr');
      const playerSearchInput = document.getElementById('player-search');
      const addPlayerButtonInitialText = addPlayerButton?.textContent || '';
      const resetMMRButtonInitialText = resetMMRButton?.textContent || '';
      const queueSection = document.getElementById('queue-builder');
      const queueTierFilters = document.getElementById('queue-tier-filters');
      const queuePlayerSearchInput = document.getElementById('queue-player-search');
      const queueAvailableList = document.getElementById('queue-available');
      const queueSelectedList = document.getElementById('queue-selected');
      const queueEmptyState = document.getElementById('queue-empty');
      const queueResetButton = document.getElementById('queue-reset');

      const SUPABASE_URL = window.APP_CONFIG?.supabaseUrl || '';
      const SUPABASE_ANON_KEY = window.APP_CONFIG?.supabaseAnonKey || '';
      let supabaseClient = null;
      let currentSession = null;
      let cachedPlayers = [];
      const queueState = {
        players: [],
        queue: [],
        selectedTiers: new Set(),
        search: ''
      };

      if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
        authStatus.textContent =
          'Configuration Supabase incompl√®te. Ajoute SUPABASE_URL et un anon key public (SUPABASE_ANON_KEY) pour activer la connexion Discord.';
        if (loginButton) {
          loginButton.disabled = true;
          loginButton.title =
            'Connexion indisponible : configure SUPABASE_ANON_KEY dans les variables d\'environnement pour activer Discord.';
        }
      } else {
        supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        authStatus.textContent = 'Connexion non √©tablie.';
      }

      const formatRank = (rank) => {
        if (rank === 1) return 'ü•á';
        if (rank === 2) return 'ü•à';
        if (rank === 3) return 'ü•â';
        return `#${rank}`;
      };

      const formatWinRate = (wins, games) => {
        if (!games) return '0% WR';
        const rate = Math.round((wins / games) * 100);
        return `${rate}% WR`;
      };

      const getWeightedScore = (player) => {
        const soloElo = typeof player.solo_elo === 'number' ? player.solo_elo : 1000;
        const mmr = typeof player.mmr === 'number' ? player.mmr : 1000;
        if (typeof player.weighted_score === 'number') {
          return player.weighted_score;
        }
        return Math.round(soloElo * 0.3 + mmr * 0.7);
      };

      const normalizeForSearch = (value) =>
        value
          ? value
              .toString()
              .normalize('NFD')
              .replace(/[\u0300-\u036f]/g, '')
              .toLowerCase()
          : '';

      const deriveQueueId = (player, index) => {
        if (player && player.id !== undefined && player.id !== null) {
          return `id:${player.id}`;
        }
        if (player && player.discord_id) {
          return `discord:${player.discord_id}`;
        }
        if (player && player.name) {
          return `name:${normalizeForSearch(player.name)}:${player.tier || 'no-tier'}`;
        }
        return `index:${index}`;
      };

      const resolveTierValue = (player) =>
        player && player.tier ? String(player.tier).toUpperCase() : 'NO-TIER';

      const createPlayerRow = (player, index) => {
        const li = document.createElement('li');
        li.className = 'player';
        if (index < 3) {
          li.classList.add('player-top', `player-top-${index + 1}`);
        }

        const rank = document.createElement('span');
        rank.className = 'rank';
        rank.textContent = formatRank(index + 1);

        const info = document.createElement('div');
        const name = document.createElement('h2');
        name.textContent = player.name;
        const subtitle = document.createElement('small');
        subtitle.textContent = `${player.games_played || 0} matchs ¬∑ ${formatWinRate(
          player.wins || 0,
          player.games_played || 0
        )}`;
        info.append(name, subtitle);

        const stats = document.createElement('div');
        stats.className = 'stats';

        const score = document.createElement('span');
        const soloElo = typeof player.solo_elo === 'number' ? player.solo_elo : 1000;
        const mmr = typeof player.mmr === 'number' ? player.mmr : 1000;
        const weightedScore = getWeightedScore(player);
        score.textContent = `${weightedScore} pts`;
        score.title = `Elo ${Math.round(soloElo)} ¬∑ MMR ${Math.round(mmr)}`;

        const tier = document.createElement('span');
        tier.classList.add('badge');
        const tierValue = player.tier ? String(player.tier).toUpperCase() : null;
        if (tierValue === 'S') {
          tier.classList.add('badge-tier-s');
        }
        tier.textContent = `Tier ${player.tier || 'No-tier'}`;

        stats.append(score, tier);

        li.append(rank, info, stats);
        return li;
      };

      function updateQueueEmptyState() {
        if (!queueEmptyState) {
          return;
        }
        queueEmptyState.hidden = queueState.queue.length > 0;
      }

      function moveQueueItem(fromIndex, toIndex) {
        if (
          fromIndex < 0 ||
          toIndex < 0 ||
          fromIndex >= queueState.queue.length ||
          toIndex >= queueState.queue.length
        ) {
          return;
        }

        const [player] = queueState.queue.splice(fromIndex, 1);
        queueState.queue.splice(toIndex, 0, player);
        refreshQueueSelected();
        refreshQueueAvailable();
      }

      function removeQueueItem(index) {
        if (index < 0 || index >= queueState.queue.length) {
          return;
        }

        queueState.queue.splice(index, 1);
        refreshQueueSelected();
        refreshQueueAvailable();
      }

      function refreshQueueSelected() {
        if (!queueSelectedList) {
          return;
        }

        queueSelectedList.innerHTML = '';

        if (!queueState.queue.length) {
          updateQueueEmptyState();
          return;
        }

        queueState.queue.forEach((player, index) => {
          const item = document.createElement('li');
          item.className = 'queue-item';

          const info = document.createElement('div');
          info.className = 'queue-info';
          const name = document.createElement('strong');
          name.textContent = `${index + 1}. ${player.name}`;
          const details = document.createElement('small');
          details.textContent = `Tier ${player.tier || 'No-tier'} ¬∑ ${getWeightedScore(player)} pts`;
          info.append(name, details);

          const actions = document.createElement('div');
          actions.className = 'queue-actions';

          const upButton = document.createElement('button');
          upButton.type = 'button';
          upButton.className = 'queue-button';
          upButton.textContent = 'Monter';
          upButton.disabled = index === 0;
          if (!upButton.disabled) {
            upButton.addEventListener('click', () => moveQueueItem(index, index - 1));
          }

          const downButton = document.createElement('button');
          downButton.type = 'button';
          downButton.className = 'queue-button';
          downButton.textContent = 'Descendre';
          downButton.disabled = index === queueState.queue.length - 1;
          if (!downButton.disabled) {
            downButton.addEventListener('click', () => moveQueueItem(index, index + 1));
          }

          const removeButton = document.createElement('button');
          removeButton.type = 'button';
          removeButton.className = 'queue-button danger';
          removeButton.textContent = 'Retirer';
          removeButton.addEventListener('click', () => removeQueueItem(index));

          actions.append(upButton, downButton, removeButton);
          item.append(info, actions);
          queueSelectedList.appendChild(item);
        });

        updateQueueEmptyState();
      }

      function refreshQueueAvailable() {
        if (!queueAvailableList) {
          return;
        }

        queueAvailableList.innerHTML = '';

        const normalizedSearch = normalizeForSearch(queueState.search);
        const activeTiers = queueState.selectedTiers;
        const queueIds = new Set(queueState.queue.map((player) => player._queueId));

        const availablePlayers = queueState.players.filter((player) => {
          if (queueIds.has(player._queueId)) {
            return false;
          }

          const tierValue = resolveTierValue(player);
          if (activeTiers.size > 0 && !activeTiers.has(tierValue)) {
            return false;
          }

          if (!normalizedSearch) {
            return true;
          }

          const searchableValues = [
            player.name,
            player.tier,
            player.discord_id,
            player.discord_tag,
            player.team
          ];
          return searchableValues.some((value) => normalizeForSearch(value).includes(normalizedSearch));
        });

        if (!availablePlayers.length) {
          const empty = document.createElement('li');
          empty.className = 'queue-empty-state';
          empty.textContent =
            activeTiers.size === 0
              ? 'S√©lectionne au moins un tier pour afficher des joueurs.'
              : 'Aucun joueur ne correspond aux filtres s√©lectionn√©s.';
          queueAvailableList.appendChild(empty);
          return;
        }

        availablePlayers.forEach((player) => {
          const item = document.createElement('li');
          item.className = 'queue-available-item';

          const info = document.createElement('div');
          info.className = 'queue-available-info';
          const name = document.createElement('strong');
          name.textContent = player.name;
          const details = document.createElement('small');
          const tierLabel = player.tier ? `Tier ${player.tier}` : 'Sans tier';
          details.textContent = `${tierLabel} ¬∑ ${getWeightedScore(player)} pts`;
          info.append(name, details);

          const addButton = document.createElement('button');
          addButton.type = 'button';
          addButton.className = 'queue-button';
          addButton.textContent = 'Ajouter';
          addButton.addEventListener('click', () => {
            queueState.queue.push(player);
            refreshQueueSelected();
            refreshQueueAvailable();
          });

          item.append(info, addButton);
          queueAvailableList.appendChild(item);
        });
      }

      function initializeQueueBuilder(players) {
        if (
          !queueSection ||
          !queueTierFilters ||
          !queueAvailableList ||
          !queueSelectedList ||
          !queueEmptyState
        ) {
          return;
        }

        queueState.players = players.map((player, index) => ({
          ...player,
          _queueId: deriveQueueId(player, index)
        }));
        queueState.queue = [];
        queueState.selectedTiers = new Set();
        queueState.search = '';

        if (queuePlayerSearchInput) {
          queuePlayerSearchInput.value = '';
        }

        queueTierFilters.innerHTML = '';

        const tiers = Array.from(
          new Set(queueState.players.map((player) => resolveTierValue(player))).values()
        ).sort((a, b) => a.localeCompare(b));

        if (!tiers.length) {
          tiers.push('NO-TIER');
        }

        tiers.forEach((tier) => {
          queueState.selectedTiers.add(tier);
          const label = document.createElement('label');
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = tier;
          input.checked = true;
          input.addEventListener('change', () => {
            if (input.checked) {
              queueState.selectedTiers.add(tier);
            } else {
              queueState.selectedTiers.delete(tier);
            }
            refreshQueueAvailable();
          });
          const span = document.createElement('span');
          span.textContent = tier === 'NO-TIER' ? 'Sans tier' : `Tier ${tier}`;
          label.append(input, span);
          queueTierFilters.appendChild(label);
        });

        queueSection.hidden = false;
        refreshQueueSelected();
        refreshQueueAvailable();
      }

      async function loadRanking() {
        try {
          const response = await fetch(`${API_BASE}/getTop50`);
          if (!response.ok) {
            throw new Error('Impossible de r√©cup√©rer les donn√©es.');
          }

          const payload = await response.json();
          if (!payload.ok || !Array.isArray(payload.top)) {
            throw new Error('Format de r√©ponse inattendu.');
          }

          if (!payload.top.length) {
            statusElement.textContent = 'Aucun joueur actif pour le moment.';
            return;
          }

          rankingElement.innerHTML = '';
          payload.top.forEach((player, index) => {
            rankingElement.appendChild(createPlayerRow(player, index));
          });

          initializeQueueBuilder(payload.top);

          statusElement.hidden = true;
          rankingElement.hidden = false;
        } catch (error) {
          console.error(error);
          statusElement.textContent = "Une erreur est survenue lors du chargement du Top 50. R√©essaie plus tard.";
        }
      }

      function buildOption(player) {
        const option = document.createElement('option');
        option.value = String(player.id);
        const weight = player.weight ? ` ¬∑ poids ${player.weight}` : '';
        option.textContent = `${player.name} (${player.mmr} MMR${weight})`;
        return option;
      }

      function populateSelects(players, { preserveSelection = false } = {}) {
        const selects = [...winnerSelects, ...loserSelects];
        const availableIds = new Set(players.map((player) => String(player.id)));
        selects.forEach((select) => {
          const previousValue = preserveSelection ? select.value : '';
          select.innerHTML = '';
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = 'S√©lectionne un joueur';
          select.appendChild(placeholder);
          players.forEach((player) => {
            select.appendChild(buildOption(player));
          });
          if (preserveSelection && previousValue && availableIds.has(previousValue)) {
            select.value = previousValue;
          } else {
            select.value = '';
          }
        });
      }

      function filterPlayersBySearch(searchTerm) {
        const normalizedSearch = normalizeForSearch(searchTerm);
        if (!normalizedSearch) {
          return cachedPlayers;
        }

        return cachedPlayers.filter((player) => {
          const normalizedName = normalizeForSearch(player.name);
          return normalizedName.includes(normalizedSearch);
        });
      }

      function refreshPlayerSelects({ preserveSelection = true } = {}) {
        const searchTerm = playerSearchInput ? playerSearchInput.value : '';
        const filteredPlayers = filterPlayersBySearch(searchTerm);
        populateSelects(filteredPlayers, { preserveSelection });
      }

      function updateAuthUI(user, isAdmin) {
        if (!user) {
          authStatus.textContent = 'Aucune session active.';
          loginButton.hidden = false;
          logoutButton.hidden = true;
          adminPanel.hidden = true;
          matchStatus.textContent = '';
          return;
        }

        authStatus.textContent = isAdmin
          ? `Connect√© en tant que ${user.full_name || user.email || 'admin'} ‚Äî acc√®s administrateur accord√©.`
          : `Connect√© en tant que ${user.full_name || user.email || 'membre'} ‚Äî acc√®s administrateur refus√©.`;
        loginButton.hidden = true;
        logoutButton.hidden = false;
        adminPanel.hidden = !isAdmin;
        if (!isAdmin) {
          matchStatus.textContent = '';
        }
      }

      function extractDiscordId(user) {
        if (!user) {
          console.warn('[extractDiscordId] Utilisateur absent dans la session.');
          return null;
        }

        const normalize = (value) => {
          if (value === undefined || value === null) {
            return null;
          }

          const stringValue = String(value).trim();
          return stringValue.length > 0 ? stringValue : null;
        };

        const identities = Array.isArray(user.identities) ? user.identities : [];
        const discordIdentity = identities.find((identity) => identity?.provider === 'discord');

        if (discordIdentity) {
          const directId = normalize(discordIdentity.id);
          if (directId) {
            return directId;
          }

          const identityData = discordIdentity.identity_data || {};
          const identityDataId = normalize(identityData.sub);
          if (identityDataId) {
            return identityDataId;
          }
        }

        const appMetadataId = normalize(user.app_metadata?.provider_id);
        if (appMetadataId) {
          return appMetadataId;
        }

        const fallbackId = normalize(user.id);
        if (fallbackId) {
          console.warn('[extractDiscordId] Retour sur user.id faute de mieux.', { userId: fallbackId });
          return fallbackId;
        }

        console.warn('[extractDiscordId] Discord ID introuvable.', {
          hasIdentities: Array.isArray(user.identities) && user.identities.length > 0
        });
        return null;
      }

      async function fetchAdminStatus(token) {
        try {
          const response = await fetch(`${API_BASE}/checkAdmin`, {
            headers: {
              Authorization: `Bearer ${token}`
            }
          });

          if (!response.ok) {
            throw new Error('Statut administrateur indisponible.');
          }

          const payload = await response.json();
          if (!payload.ok) {
            throw new Error(payload.error || 'Statut administrateur indisponible.');
          }

          updateAuthUI(payload.user, payload.isAdmin);
          if (payload.isAdmin) {
            await loadPlayers(token);
          }
        } catch (error) {
          console.error(error);
          updateAuthUI(null, false);
        }
      }

      async function autoRegisterPlayer(token) {
        if (!token || !supabaseClient || !currentSession?.user) {
          return;
        }

        const discordId = extractDiscordId(currentSession.user);
        if (!discordId) {
          console.warn('Impossible de d√©terminer le Discord ID de la session en cours.');
          return;
        }
        let alreadyRegistered = false;

        try {
          const { data, error } = await supabaseClient
            .from('players')
            .select('id')
            .eq('discord_id', discordId)
            .maybeSingle();

          if (error) {
            throw error;
          }

          if (data) {
            alreadyRegistered = true;
          }
        } catch (error) {
          console.warn('Impossible de v√©rifier le joueur existant.', error);
        }

        if (alreadyRegistered) {
          return;
        }

        try {
          const response = await fetch(`${API_BASE}/autoRegister`, {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${token}`
            }
          });

          if (!response.ok) {
            return;
          }

          await response.json().catch(() => null);
        } catch (error) {
          console.warn('Auto-inscription √©chou√©e.', error);
        }
      }

      async function loadPlayers(token) {
        try {
          const response = await fetch(`${API_BASE}/getPlayers`, {
            headers: {
              Authorization: `Bearer ${token}`
            }
          });

          if (!response.ok) {
            throw new Error('Impossible de charger les joueurs.');
          }

          const payload = await response.json();
          if (!payload.ok || !Array.isArray(payload.players)) {
            throw new Error('R√©ponse invalide.');
          }

          cachedPlayers = payload.players;
          refreshPlayerSelects({ preserveSelection: true });
        } catch (error) {
          console.error(error);
          matchStatus.textContent = "Erreur lors du chargement des joueurs.";
          matchStatus.className = 'admin-message error';
        }
      }

      async function handleSession(session) {
        currentSession = session;
        if (!session) {
          updateAuthUI(null, false);
          return;
        }
        await fetchAdminStatus(session.access_token);
        await autoRegisterPlayer(session.access_token);
      }

      if (supabaseClient) {
        supabaseClient.auth.getSession().then(({ data }) => {
          handleSession(data.session);
        });

        supabaseClient.auth.onAuthStateChange((_event, session) => {
          handleSession(session);
        });
      }

      if (playerSearchInput) {
        playerSearchInput.addEventListener('input', () => {
          refreshPlayerSelects({ preserveSelection: true });
        });
      }

      if (queuePlayerSearchInput) {
        queuePlayerSearchInput.addEventListener('input', (event) => {
          queueState.search = event.target.value || '';
          refreshQueueAvailable();
        });
      }

      if (queueResetButton) {
        queueResetButton.addEventListener('click', () => {
          queueState.queue = [];
          refreshQueueSelected();
          refreshQueueAvailable();
        });
      }

      if (loginButton) {
        loginButton.addEventListener('click', async () => {
          if (!supabaseClient) {
            alert('Configuration Supabase manquante.');
            return;
          }

          loginButton.disabled = true;
          loginButton.textContent = 'Redirection en cours‚Ä¶';
          const { data, error } = await supabaseClient.auth.signInWithOAuth({
            provider: 'discord',
            options: {
              redirectTo: window.location.origin
            }
          });

          if (error) {
            console.error(error);
            loginButton.disabled = false;
            loginButton.textContent = 'Connexion Discord';
            const errorMessage = String(error.message || error.error_description || error.error || '').toLowerCase();
            if (errorMessage.includes('provider is not enabled')) {
              authStatus.textContent =
                'La connexion Discord est d√©sactiv√©e sur Supabase. Active le fournisseur Discord dans le tableau de bord Supabase > Authentication > Providers.';
            } else {
              authStatus.textContent = "La connexion a √©chou√©. V√©rifie la configuration Supabase et r√©essaie.";
            }
            return;
          }

          window.location.href = data.url;
        });
      }

      if (logoutButton) {
        logoutButton.addEventListener('click', async () => {
          if (!supabaseClient) return;
          await supabaseClient.auth.signOut();
        });
      }

      if (addPlayerButton) {
        addPlayerButton.addEventListener('click', async () => {
          if (!currentSession) {
            matchStatus.textContent = 'Tu dois √™tre connect√© pour ajouter un joueur.';
            matchStatus.className = 'admin-message error';
            return;
          }

          const enteredName = window.prompt('Nom du nouveau joueur √† inscrire ?');
          if (enteredName === null) {
            return;
          }

          const trimmedName = enteredName.trim();
          if (!trimmedName) {
            matchStatus.textContent = 'Le nom du joueur ne peut pas √™tre vide.';
            matchStatus.className = 'admin-message error';
            return;
          }

          const weightInput = window.prompt('Poids du joueur (optionnel, 1 par d√©faut)');
          let weightPayload;
          if (weightInput !== null && weightInput.trim()) {
            const normalizedWeight = weightInput.replace(',', '.').trim();
            const parsedWeight = Number(normalizedWeight);
            if (!Number.isFinite(parsedWeight) || parsedWeight <= 0) {
              matchStatus.textContent = 'Le poids doit √™tre un nombre positif.';
              matchStatus.className = 'admin-message error';
              return;
            }
            weightPayload = parsedWeight;
          }

          addPlayerButton.disabled = true;
          addPlayerButton.textContent = 'Ajout en cours‚Ä¶';
          matchStatus.textContent = 'Ajout du joueur‚Ä¶';
          matchStatus.className = 'admin-message';

          try {
            const response = await fetch(`${API_BASE}/createPlayer`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentSession.access_token}`
              },
              body: JSON.stringify({
                name: trimmedName,
                ...(weightPayload ? { weight: weightPayload } : {})
              })
            });

            const payload = await response.json().catch(() => null);
            if (!response.ok || !payload?.ok) {
              const errorCode = payload?.error;
              let errorMessage = 'Impossible d‚Äôajouter le joueur.';
              if (errorCode === 'duplicate_player') {
                errorMessage = 'Un joueur avec ce nom existe d√©j√†.';
              } else if (errorCode === 'invalid_name') {
                errorMessage = 'Le nom du joueur est invalide.';
              } else if (errorCode === 'forbidden') {
                errorMessage = 'Tu n‚Äôas pas l‚Äôautorisation d‚Äôajouter un joueur.';
              }
              throw new Error(errorMessage);
            }

            matchStatus.textContent = `Joueur ¬´ ${payload.player.name} ¬ª ajout√© avec succ√®s.`;
            matchStatus.className = 'admin-message success';

            await loadPlayers(currentSession.access_token);
            loadRanking();
          } catch (error) {
            console.error(error);
            matchStatus.textContent =
              error instanceof Error && error.message
                ? error.message
                : "Une erreur est survenue lors de l'ajout du joueur.";
            matchStatus.className = 'admin-message error';
          } finally {
            addPlayerButton.disabled = false;
            addPlayerButton.textContent = addPlayerButtonInitialText;
          }
        });
      }

      if (resetMMRButton) {
        resetMMRButton.addEventListener('click', async () => {
          if (!currentSession) {
            matchStatus.textContent = 'Tu dois √™tre connect√© pour r√©initialiser les MMR.';
            matchStatus.className = 'admin-message error';
            return;
          }

          const confirmed = window.confirm(
            'Es-tu s√ªr de vouloir r√©initialiser le MMR de tous les joueurs √† 1000 ? Cette action est irr√©versible.'
          );

          if (!confirmed) {
            return;
          }

          const confirmationKeyword = window.prompt('Tape "RESET" pour confirmer la r√©initialisation globale des MMR.');
          if ((confirmationKeyword || '').trim().toUpperCase() !== 'RESET') {
            matchStatus.textContent = 'R√©initialisation annul√©e.';
            matchStatus.className = 'admin-message';
            return;
          }

          resetMMRButton.disabled = true;
          resetMMRButton.textContent = 'R√©initialisation‚Ä¶';
          matchStatus.textContent = 'R√©initialisation des MMR en cours‚Ä¶';
          matchStatus.className = 'admin-message';

          try {
            const response = await fetch(`${API_BASE}/resetMMR`, {
              method: 'POST',
              headers: {
                Authorization: `Bearer ${currentSession.access_token}`
              }
            });

            const payload = await response.json().catch(() => null);

            if (!response.ok || !payload?.ok) {
              const errorCode = payload?.error;
              const detailedMessage = payload?.message;
              let errorMessage = detailedMessage || 'La r√©initialisation des MMR a √©chou√©.';
              if (errorCode === 'forbidden') {
                errorMessage = detailedMessage || 'Tu n‚Äôas pas l‚Äôautorisation de r√©initialiser les MMR.';
              }
              throw new Error(errorMessage);
            }

            const updatedCount = typeof payload.updated === 'number' ? payload.updated : null;
            matchStatus.textContent = updatedCount
              ? `MMR r√©initialis√©s pour ${updatedCount} joueur${updatedCount > 1 ? 's' : ''}.`
              : 'Tous les MMR ont √©t√© r√©initialis√©s.';
            matchStatus.className = 'admin-message success';

            await loadPlayers(currentSession.access_token);
            loadRanking();
          } catch (error) {
            console.error(error);
            matchStatus.textContent =
              error instanceof Error && error.message
                ? error.message
                : 'La r√©initialisation des MMR a √©chou√©.';
            matchStatus.className = 'admin-message error';
          } finally {
            resetMMRButton.disabled = false;
            resetMMRButton.textContent = resetMMRButtonInitialText;
          }
        });
      }

      if (matchForm) {
        matchForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (!currentSession) {
            matchStatus.textContent = 'Tu dois √™tre connect√© pour effectuer cette action.';
            matchStatus.className = 'admin-message error';
            return;
          }

          const winners = winnerSelects.map((select) => select.value).filter(Boolean);
          const losers = loserSelects.map((select) => select.value).filter(Boolean);

          if (winners.length !== 3 || losers.length !== 3) {
            matchStatus.textContent = 'S√©lectionne exactement trois vainqueurs et trois perdants.';
            matchStatus.className = 'admin-message error';
            return;
          }

          const uniqueIds = new Set([...winners, ...losers]);
          if (uniqueIds.size !== 6) {
            matchStatus.textContent = 'Un joueur ne peut √™tre s√©lectionn√© qu‚Äôune seule fois.';
            matchStatus.className = 'admin-message error';
            return;
          }

          matchStatus.textContent = 'Enregistrement du match‚Ä¶';
          matchStatus.className = 'admin-message';

          try {
            const response = await fetch(`${API_BASE}/submitMatch`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentSession.access_token}`
              },
              body: JSON.stringify({ winners, losers })
            });

            if (!response.ok) {
              throw new Error('La mise √† jour a √©chou√©.');
            }

            const payload = await response.json();
            if (!payload.ok) {
              throw new Error(payload.error || 'La mise √† jour a √©chou√©.');
            }

            matchStatus.textContent = 'Match enregistr√© et MMR mis √† jour avec succ√®s.';
            matchStatus.className = 'admin-message success';
            await loadPlayers(currentSession.access_token);
            matchForm.reset();
            loadRanking();
          } catch (error) {
            console.error(error);
            matchStatus.textContent = "Une erreur est survenue lors de l'enregistrement.";
            matchStatus.className = 'admin-message error';
          }
        });
      }

      loadRanking();
    </script>
  </body>
</html>
